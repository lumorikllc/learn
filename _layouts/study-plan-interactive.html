---
layout: default
---

<article class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Hero Section -->
    <div class="bg-gradient-to-r from-purple-600 to-pink-600 rounded-xl sm:rounded-2xl p-4 sm:p-6 md:p-8 text-white mb-6 sm:mb-8">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4 gap-2">
            <span class="px-3 py-1 bg-white/20 rounded-full text-xs sm:text-sm inline-block w-fit">Interactive Study Plan</span>
            <span class="text-xs sm:text-sm opacity-90">{{ page.date | date: "%B %d, %Y" }}</span>
        </div>
        <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold mb-4">{{ page.title }}</h1>
        <div class="flex flex-wrap gap-3 sm:gap-4">
            <div class="flex items-center space-x-2">
                <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                </svg>
                <span class="text-sm sm:text-base font-medium">{{ page.modules }} Modules</span>
            </div>
            <div class="flex items-center space-x-2">
                <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <span class="text-sm sm:text-base font-medium">{{ page.lessons }} Lessons</span>
            </div>
        </div>
        
        <!-- View Toggle Buttons -->
        <div class="mt-4 flex gap-2">
            <button id="view-knowledge" class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg transition-colors text-sm font-medium">
                üó∫Ô∏è Knowledge Map
            </button>
            <button id="view-list" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition-colors text-sm font-medium">
                üìù List View
            </button>
        </div>
    </div>

    <!-- Interactive Visualization Container -->
    <div id="visualization-container" class="mb-6">
        
        <!-- Knowledge Graph View -->
        <div id="knowledge-graph-view" class="bg-gray-900 rounded-xl shadow-lg border border-gray-800 overflow-hidden" style="width: 100%; height: 900px;">
            <!-- Canvas for Knowledge Graph -->
            <canvas id="knowledge-graph-canvas" style="width: 100%; height: 100%;"></canvas>
        </div>
        
        <!-- List View (Traditional) - Hidden by default -->
        <div id="list-view" class="hidden bg-white rounded-xl shadow-sm border border-gray-200 p-4 sm:p-6 md:p-8">
            <div class="prose max-w-none">
                {{ content }}
            </div>
        </div>
    </div>

    <!-- CTA Section -->
    <div class="mt-8 sm:mt-12 bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl sm:rounded-2xl p-4 sm:p-6 md:p-8 text-center">
        <h2 class="text-xl sm:text-2xl font-bold text-gray-900 mb-3 sm:mb-4">Ready to Start Learning?</h2>
        <p class="text-sm sm:text-base text-gray-600 mb-4 sm:mb-6">Join thousands of learners using Lumorik AI to achieve their goals.</p>
        <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center">
            <a href="https://ai.tutor.lumorik.com" class="px-4 sm:px-6 py-2.5 sm:py-3 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-lg hover:shadow-lg transition font-medium text-sm sm:text-base">
                Start Your Journey
            </a>
            <a href="{{ '/' | relative_url }}" class="px-4 sm:px-6 py-2.5 sm:py-3 bg-white text-gray-700 rounded-lg border border-gray-300 hover:border-gray-400 transition font-medium text-sm sm:text-base">
                Browse More Plans
            </a>
        </div>
    </div>
</article>

<!-- Knowledge Graph Visualization Script -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('knowledge-graph-canvas');
    const ctx = canvas.getContext('2d');
    
    // High DPI support
    const dpr = window.devicePixelRatio || 1;
    
    // Set actual canvas size
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Helper function to darken a color
    function darkenColor(color, amount) {
        // Convert hex to RGB
        const hex = color.replace('#', '');
        const r = parseInt(hex.substring(0, 2), 16);
        const g = parseInt(hex.substring(2, 4), 16);
        const b = parseInt(hex.substring(4, 6), 16);
        
        // Darken by reducing RGB values
        const newR = Math.max(0, Math.floor(r * (1 - amount)));
        const newG = Math.max(0, Math.floor(g * (1 - amount)));
        const newB = Math.max(0, Math.floor(b * (1 - amount)));
        
        // Convert back to hex
        const toHex = (n) => n.toString(16).padStart(2, '0');
        return `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
    }
    
    // Parse study plan data
    const listView = document.getElementById('list-view');
    const proseDiv = listView.querySelector('.prose') || listView;
    const studyPlanData = parseStudyPlan(proseDiv.innerHTML);
    
    // Color schemes for different module categories
    const colorSchemes = {
        fundamentals: { bg: '#3b82f6', border: '#2563eb', text: '#ffffff' }, // Blue
        architecture: { bg: '#8b5cf6', border: '#7c3aed', text: '#ffffff' }, // Purple
        operations: { bg: '#ec4899', border: '#db2777', text: '#ffffff' },   // Pink
        networking: { bg: '#06b6d4', border: '#0891b2', text: '#ffffff' },   // Cyan
        storage: { bg: '#f59e0b', border: '#d97706', text: '#ffffff' },      // Amber
        security: { bg: '#ef4444', border: '#dc2626', text: '#ffffff' },     // Red
        monitoring: { bg: '#10b981', border: '#059669', text: '#ffffff' },   // Emerald
        advanced: { bg: '#6366f1', border: '#4f46e5', text: '#ffffff' }      // Indigo
    };
    
    const moduleColors = [
        colorSchemes.fundamentals,
        colorSchemes.architecture,
        colorSchemes.operations,
        colorSchemes.networking,
        colorSchemes.storage,
        colorSchemes.security,
        colorSchemes.monitoring,
        colorSchemes.advanced
    ];
    
    // Layout configuration
    let boxes = [];
    let connections = [];
    let hoveredBox = null;
    
    function parseStudyPlan(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        const planData = {
            title: "{{ page.title }}",
            modules: []
        };
        
        let currentModule = null;
        let moduleIndex = 0;
        
        // Find all elements and parse
        const allElements = doc.body.querySelectorAll('*');
        
        allElements.forEach(elem => {
            if (elem.tagName === 'H3' && elem.textContent.includes('Module')) {
                moduleIndex++;
                // Extract emoji icon if present (will be at the beginning)
                const text = elem.textContent;
                let icon = 'üìö'; // Default icon
                let name = text.replace(/Module \d+: /, '');
                
                // Check if first character is an emoji
                const emojiMatch = text.match(/^([\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}])/u);
                if (emojiMatch) {
                    icon = emojiMatch[0];
                    name = text.substring(icon.length).replace(/Module \d+: /, '').trim();
                }
                
                currentModule = {
                    name: name,
                    icon: icon,
                    index: moduleIndex,
                    subtopics: [],
                    description: ''
                };
                planData.modules.push(currentModule);
            } else if (elem.tagName === 'P' && currentModule && !currentModule.subtopics.length && elem.textContent.trim()) {
                currentModule.description = elem.textContent.substring(0, 100) + '...';
            } else if (elem.tagName === 'UL' && currentModule) {
                const items = elem.querySelectorAll('li');
                items.forEach((item, idx) => {
                    if (idx < 5) { // Limit to 5 subtopics for space
                        const link = item.querySelector('a');
                        currentModule.subtopics.push({
                            name: link ? link.textContent.replace(' üìñ', '') : item.textContent,
                            hasTextbook: link !== null
                        });
                    }
                });
            }
        });
        
        return planData;
    }
    
    function createLayout(data) {
        boxes = [];
        connections = [];
        
        const canvasWidth = canvas.width / dpr;
        const canvasHeight = canvas.height / dpr;
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;
        
        // Center title box (main topic) with gradient
        const titleBox = {
            id: 'title',
            text: data.title,
            x: centerX - 150,
            y: centerY - 30,
            width: 300,
            height: 60,
            color: { bg: '#9333ea', border: '#ec4899', text: '#ffffff' }, // Purple to pink gradient colors
            type: 'title',
            fontSize: 16,
            fontWeight: 'bold',
            gradient: true // Flag to apply gradient
        };
        boxes.push(titleBox);
        
        // Define positions for 8 modules: 2 top, 2 left, 2 right, 2 bottom
        const moduleWidth = 160;
        const moduleHeight = 45;
        const positions = [];
        
        // Top (2 modules) - more vertical spacing from center
        const topY = 180; // Higher up with more spacing
        const topLeftX = centerX - 320; // More to the left with increased spacing
        const topRightX = centerX + 160; // More to the right with increased spacing
        positions.push({ x: topLeftX, y: topY, side: 'top' });
        positions.push({ x: topRightX, y: topY, side: 'top' });
        
        // Left side (2 modules) - slightly less vertical spacing
        const leftX = 220; // Closer to center
        const sideSpacing = 260; // Less vertical spacing between side modules
        positions.push({ x: leftX, y: centerY - sideSpacing/2, side: 'left' });
        positions.push({ x: leftX, y: centerY + sideSpacing/2, side: 'left' });
        
        // Right side (2 modules) - slightly less vertical spacing
        const rightX = canvasWidth - 380; // Closer to center
        positions.push({ x: rightX, y: centerY - sideSpacing/2, side: 'right' });
        positions.push({ x: rightX, y: centerY + sideSpacing/2, side: 'right' });
        
        // Bottom (2 modules) - more vertical spacing from center
        const bottomY = canvasHeight - 180; // Lower with more spacing
        const bottomLeftX = centerX - 320; // More to the left with increased spacing
        const bottomRightX = centerX + 160; // More to the right with increased spacing
        positions.push({ x: bottomLeftX, y: bottomY, side: 'bottom' });
        positions.push({ x: bottomRightX, y: bottomY, side: 'bottom' });
        
        data.modules.forEach((module, idx) => {
            if (idx >= positions.length) return; // Safety check
            
            const pos = positions[idx];
            const x = pos.x;
            const y = pos.y;
            
            // Module container box with icon
            const moduleBox = {
                id: `module-${idx}`,
                text: module.name.length > 25 ? module.name.substring(0, 25) + '...' : module.name,
                icon: module.icon || 'üìö',  // Use module icon or default
                x: x,
                y: y,
                width: moduleWidth,
                height: 50,
                color: moduleColors[idx % moduleColors.length],
                type: 'module',
                fontSize: 13,
                fontWeight: 'bold',
                module: module,
                side: pos.side,  // Add side property for connection drawing
                maxLines: 2  // Enforce max 2 lines
            };
            boxes.push(moduleBox);
            
            // Connect to title with dashed line
            connections.push({
                from: titleBox,
                to: moduleBox,
                style: 'dashed'
            });
            
            // Add subtopic boxes - position based on module location
            const subtopicWidth = 140;
            const subtopicHeight = 26;
            const side = pos.side;
            
            // Different spacing for sides vs bottom
            const sideSubtopicSpacing = 20; // Much more vertical spacing for sides to prevent overlap
            const bottomSubtopicSpacing = 15; // Horizontal spacing for bottom
            
            // Calculate total height needed for side subtopics
            const totalSubtopicHeight = module.subtopics.length * (subtopicHeight + sideSubtopicSpacing) - sideSubtopicSpacing;
            const startOffset = -totalSubtopicHeight / 2 + moduleHeight / 2;
            
            module.subtopics.forEach((subtopic, subIdx) => {
                let subtopicX, subtopicY;
                
                // Position subtopics based on which side the module is on
                if (side === 'top') {
                    // Top modules - subtopics ABOVE in 2 rows (2 on top, 3 on bottom)
                    const topSubtopicSpacing = 15; // Horizontal spacing
                    const rowSpacing = 35; // Vertical spacing between rows
                    
                    if (module.subtopics.length <= 3) {
                        // For 3 or fewer, single row centered above
                        const totalWidth = module.subtopics.length * (subtopicWidth + topSubtopicSpacing) - topSubtopicSpacing;
                        const startX = x + (moduleWidth - totalWidth) / 2;
                        subtopicX = startX + subIdx * (subtopicWidth + topSubtopicSpacing);
                        subtopicY = y - subtopicHeight - 20;
                    } else {
                        // For 4-5 subtopics, use 2 rows (2 on top, 3 on bottom)
                        const topRowCount = 2;
                        const bottomRowCount = module.subtopics.length - topRowCount;
                        
                        if (subIdx < topRowCount) {
                            // Top row (2 items) - further above
                            const totalWidth = topRowCount * (subtopicWidth + topSubtopicSpacing) - topSubtopicSpacing;
                            const startX = x + (moduleWidth - totalWidth) / 2;
                            subtopicX = startX + subIdx * (subtopicWidth + topSubtopicSpacing);
                            subtopicY = y - subtopicHeight - 20 - rowSpacing;
                        } else {
                            // Bottom row (3 items) - closer to module
                            const rowIdx = subIdx - topRowCount;
                            const totalWidth = bottomRowCount * (subtopicWidth + topSubtopicSpacing) - topSubtopicSpacing;
                            const startX = x + (moduleWidth - totalWidth) / 2;
                            subtopicX = startX + rowIdx * (subtopicWidth + topSubtopicSpacing);
                            subtopicY = y - subtopicHeight - 20;
                        }
                    }
                } else if (side === 'left') {
                    // Left side modules - subtopics to the LEFT with more vertical spacing
                    subtopicX = x - subtopicWidth - 15;
                    subtopicY = y + startOffset + subIdx * (subtopicHeight + sideSubtopicSpacing);
                } else if (side === 'bottom') {
                    // Bottom modules - subtopics UNDERNEATH in 2 rows (2 on top, 3 on bottom)
                    const bottomSubtopicSpacing = 15; // Horizontal spacing
                    const rowSpacing = 35; // Vertical spacing between rows
                    
                    if (module.subtopics.length <= 3) {
                        // For 3 or fewer, single row centered
                        const totalWidth = module.subtopics.length * (subtopicWidth + bottomSubtopicSpacing) - bottomSubtopicSpacing;
                        const startX = x + (moduleWidth - totalWidth) / 2;
                        subtopicX = startX + subIdx * (subtopicWidth + bottomSubtopicSpacing);
                        subtopicY = y + moduleHeight + 20;
                    } else {
                        // For 4-5 subtopics, use 2 rows (2 on top, rest on bottom)
                        const topRowCount = 2;
                        const bottomRowCount = module.subtopics.length - topRowCount;
                        
                        if (subIdx < topRowCount) {
                            // Top row (2 items)
                            const totalWidth = topRowCount * (subtopicWidth + bottomSubtopicSpacing) - bottomSubtopicSpacing;
                            const startX = x + (moduleWidth - totalWidth) / 2;
                            subtopicX = startX + subIdx * (subtopicWidth + bottomSubtopicSpacing);
                            subtopicY = y + moduleHeight + 20;
                        } else {
                            // Bottom row (3 items)
                            const rowIdx = subIdx - topRowCount;
                            const totalWidth = bottomRowCount * (subtopicWidth + bottomSubtopicSpacing) - bottomSubtopicSpacing;
                            const startX = x + (moduleWidth - totalWidth) / 2;
                            subtopicX = startX + rowIdx * (subtopicWidth + bottomSubtopicSpacing);
                            subtopicY = y + moduleHeight + 20 + rowSpacing;
                        }
                    }
                } else if (side === 'right') {
                    // Right side modules - subtopics to the RIGHT with more vertical spacing
                    subtopicX = x + moduleWidth + 15;
                    subtopicY = y + startOffset + subIdx * (subtopicHeight + sideSubtopicSpacing);
                }
                
                // Get parent module color and create darker version for subtopic
                const parentColor = moduleColors[idx % moduleColors.length];
                const subtopicBgColor = darkenColor(parentColor.bg, 0.4); // 40% darker
                
                const subtopicBox = {
                    id: `subtopic-${idx}-${subIdx}`,
                    text: subtopic.name.length > 20 ? subtopic.name.substring(0, 20) + '...' : subtopic.name,
                    x: subtopicX,
                    y: subtopicY,
                    width: subtopicWidth,
                    height: subtopicHeight,
                    color: { 
                        bg: subtopicBgColor, 
                        border: parentColor.bg, // Use parent module color as border
                        text: '#ffffff' 
                    },
                    type: 'subtopic',
                    fontSize: 10,
                    fontWeight: 'normal',
                    hasTextbook: subtopic.hasTextbook,
                    maxLines: 2  // Enforce max 2 lines
                };
                boxes.push(subtopicBox);
                
                // Connect to module with dashed line
                connections.push({
                    from: { ...moduleBox, side: pos.side },
                    to: subtopicBox,
                    style: 'dashed'
                });
            });
            
            // Connect modules in learning sequence (optional - can be removed if too cluttered)
            // We'll skip sequential connections to keep it cleaner like the reference
        });
    }
    
    function drawBox(box) {
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(box.x + 2, box.y + 2, box.width, box.height);
        
        // Draw box background (with gradient for title box)
        if (box.gradient && box.type === 'title') {
            // Create purple to pink gradient for title box
            const gradient = ctx.createLinearGradient(box.x, box.y, box.x + box.width, box.y);
            gradient.addColorStop(0, '#9333ea'); // Purple
            gradient.addColorStop(1, '#ec4899'); // Pink
            ctx.fillStyle = gradient;
        } else {
            ctx.fillStyle = box.color.bg;
        }
        ctx.fillRect(box.x, box.y, box.width, box.height);
        
        // Draw border (skip for main modules and title)
        if (box.type !== 'module' && box.type !== 'title') {
            ctx.strokeStyle = box.color.border;
            ctx.lineWidth = box === hoveredBox ? 3 : 2;
            ctx.strokeRect(box.x, box.y, box.width, box.height);
        }
        
        // Draw icon for modules (outside the box)
        // Left-side modules: icon on the right
        // Right-side modules: icon on the left
        if (box.type === 'module' && box.icon) {
            ctx.font = '24px system-ui, -apple-system, sans-serif';
            ctx.fillStyle = box.color.text;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Position icon based on module side
            let iconX;
            if (box.side === 'left') {
                // Left modules: icon on the right side
                iconX = box.x + box.width + 20;
            } else if (box.side === 'right') {
                // Right modules: icon on the left side
                iconX = box.x - 20;
            } else if (box.side === 'top') {
                // Top modules: decide based on x position relative to center
                const canvasCenter = canvas.width / (2 * dpr);
                if (box.x < canvasCenter) {
                    // Left-side top module: icon on right
                    iconX = box.x + box.width + 20;
                } else {
                    // Right-side top module: icon on left
                    iconX = box.x - 20;
                }
            } else if (box.side === 'bottom') {
                // Bottom modules: decide based on x position relative to center
                const canvasCenter = canvas.width / (2 * dpr);
                if (box.x < canvasCenter) {
                    // Left-side bottom module: icon on right
                    iconX = box.x + box.width + 20;
                } else {
                    // Right-side bottom module: icon on left
                    iconX = box.x - 20;
                }
            }
            
            ctx.fillText(box.icon, iconX, box.y + box.height / 2);
        }
        
        // Draw text
        ctx.fillStyle = box.color.text;
        ctx.font = `${box.fontWeight} ${box.fontSize}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw text (handle multiline for long text, max 2 lines without ellipsis)
        const maxWidth = box.width - 20;
        const words = box.text.split(' ');
        let line = '';
        let lines = [];
        
        words.forEach(word => {
            const testLine = line + (line ? ' ' : '') + word;
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && line) {
                lines.push(line);
                line = word;
            } else {
                line = testLine;
            }
        });
        if (line) lines.push(line);
        
        // Limit to 2 lines max (no ellipsis, just show what fits)
        if (lines.length > 2) {
            lines = lines.slice(0, 2);
        }
        
        const lineHeight = box.fontSize + 4;
        const startY = box.y + box.height / 2 - (lines.length - 1) * lineHeight / 2;
        const textX = box.x + box.width / 2;
        lines.forEach((text, idx) => {
            ctx.fillText(text, textX, startY + idx * lineHeight);
        });
        
        // Add textbook icon if applicable
        if (box.hasTextbook) {
            ctx.fillText('üìñ', box.x + box.width - 15, box.y + 15);
        }
    }
    
    function drawConnection(conn) {
        const fromCenter = {
            x: conn.from.x + conn.from.width / 2,
            y: conn.from.y + conn.from.height / 2
        };
        const toCenter = {
            x: conn.to.x + conn.to.width / 2,
            y: conn.to.y + conn.to.height / 2
        };
        
        ctx.strokeStyle = conn.color || '#6b7280';
        ctx.lineWidth = conn.style === 'dashed' ? 1 : 2;
        
        if (conn.style === 'dashed') {
            ctx.setLineDash([5, 5]);
        } else {
            ctx.setLineDash([]);
        }
        
        ctx.beginPath();
        
        // Different connection styles based on connection type
        if (conn.from.type === 'title' && conn.to.type === 'module') {
            // Title to module connections - straight dashed lines (same as module to subtopic)
            const side = conn.to.side || 'left';
            let fromPoint, toPoint;
            
            if (side === 'top') {
                fromPoint = { x: fromCenter.x, y: conn.from.y };
                toPoint = { x: toCenter.x, y: conn.to.y + conn.to.height };
            } else if (side === 'bottom') {
                fromPoint = { x: fromCenter.x, y: conn.from.y + conn.from.height };
                toPoint = { x: toCenter.x, y: conn.to.y };
            } else if (side === 'left') {
                fromPoint = { x: conn.from.x, y: fromCenter.y };
                toPoint = { x: conn.to.x + conn.to.width, y: toCenter.y };
            } else if (side === 'right') {
                fromPoint = { x: conn.from.x + conn.from.width, y: fromCenter.y };
                toPoint = { x: conn.to.x, y: toCenter.y };
            }
            
            ctx.moveTo(fromPoint.x, fromPoint.y);
            ctx.lineTo(toPoint.x, toPoint.y);
        } else if (conn.to.type === 'subtopic') {
            // Module to subtopic connections - straight dashed lines
            const side = conn.from.side || 'left';
            let fromPoint, toPoint;
            
            if (side === 'left') {
                fromPoint = { x: conn.from.x, y: fromCenter.y };
                toPoint = { x: conn.to.x + conn.to.width, y: toCenter.y };
            } else if (side === 'right') {
                fromPoint = { x: conn.from.x + conn.from.width, y: fromCenter.y };
                toPoint = { x: conn.to.x, y: toCenter.y };
            } else if (side === 'top') {
                fromPoint = { x: fromCenter.x, y: conn.from.y };
                toPoint = { x: toCenter.x, y: conn.to.y + conn.to.height };
            } else if (side === 'bottom') {
                fromPoint = { x: fromCenter.x, y: conn.from.y + conn.from.height };
                toPoint = { x: toCenter.x, y: conn.to.y };
            }
            
            ctx.moveTo(fromPoint.x, fromPoint.y);
            ctx.lineTo(toPoint.x, toPoint.y);
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
    }
    
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        
        // Draw connections first
        connections.forEach(conn => drawConnection(conn));
        
        // Draw boxes on top
        boxes.forEach(box => drawBox(box));
    }
    
    // Simple hover interaction only (no dragging)
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Check hover
        const prevHovered = hoveredBox;
        hoveredBox = null;
        
        boxes.forEach(box => {
            if (x >= box.x && x <= box.x + box.width &&
                y >= box.y && y <= box.y + box.height) {
                hoveredBox = box;
                canvas.style.cursor = 'pointer';
            }
        });
        
        if (!hoveredBox) {
            canvas.style.cursor = 'default';
        }
        
        if (prevHovered !== hoveredBox) {
            draw();
        }
    });
    
    // View toggles
    document.getElementById('view-knowledge').addEventListener('click', () => {
        document.getElementById('knowledge-graph-view').classList.remove('hidden');
        document.getElementById('list-view').classList.add('hidden');
        document.getElementById('view-knowledge').classList.add('bg-white/20');
        document.getElementById('view-knowledge').classList.remove('bg-white/10');
        document.getElementById('view-list').classList.add('bg-white/10');
        document.getElementById('view-list').classList.remove('bg-white/20');
        resizeCanvas();
        draw();
    });
    
    document.getElementById('view-list').addEventListener('click', () => {
        document.getElementById('list-view').classList.remove('hidden');
        document.getElementById('knowledge-graph-view').classList.add('hidden');
        document.getElementById('view-list').classList.add('bg-white/20');
        document.getElementById('view-list').classList.remove('bg-white/10');
        document.getElementById('view-knowledge').classList.add('bg-white/10');
        document.getElementById('view-knowledge').classList.remove('bg-white/20');
    });
    
    // Initialize
    createLayout(studyPlanData);
    draw();
});
</script>

<style>
#knowledge-graph-canvas {
    cursor: default;
    image-rendering: crisp-edges;
}

#knowledge-graph-view {
    user-select: none;
}
</style>