---
layout: default
---

<article class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
    <!-- Hero Section -->
    <div class="bg-gradient-to-r from-purple-600 to-pink-600 rounded-xl sm:rounded-2xl p-4 sm:p-6 md:p-8 text-white mb-6 sm:mb-8">
        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-4 gap-2">
            <span class="px-3 py-1 bg-white/20 rounded-full text-xs sm:text-sm inline-block w-fit">Interactive Study Plan</span>
            <span class="text-xs sm:text-sm opacity-90">{{ page.date | date: "%B %d, %Y" }}</span>
        </div>
        <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold mb-4">{{ page.title }}</h1>
        <div class="flex flex-wrap gap-3 sm:gap-4">
            <div class="flex items-center space-x-2">
                <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                </svg>
                <span class="text-sm sm:text-base font-medium">{{ page.modules }} Modules</span>
            </div>
            <div class="flex items-center space-x-2">
                <svg class="w-4 h-4 sm:w-5 sm:h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                </svg>
                <span class="text-sm sm:text-base font-medium">{{ page.lessons }} Lessons</span>
            </div>
        </div>
        
        <!-- View Toggle Buttons -->
        <div class="mt-4 flex gap-2">
            <button id="view-knowledge" class="px-4 py-2 bg-white/20 hover:bg-white/30 rounded-lg transition-colors text-sm font-medium">
                üó∫Ô∏è Knowledge Map
            </button>
            <button id="view-list" class="px-4 py-2 bg-white/10 hover:bg-white/20 rounded-lg transition-colors text-sm font-medium">
                üìù List View
            </button>
        </div>
    </div>

    <!-- Interactive Visualization Container -->
    <div id="visualization-container" class="mb-6">
        
        <!-- Knowledge Graph View -->
        <div id="knowledge-graph-view" class="bg-gray-900 rounded-xl shadow-lg border border-gray-800 overflow-hidden" style="height: 800px;">
            <!-- Canvas for Knowledge Graph -->
            <canvas id="knowledge-graph-canvas" style="width: 100%; height: 100%;"></canvas>
        </div>
        
        <!-- List View (Traditional) - Hidden by default -->
        <div id="list-view" class="hidden bg-white rounded-xl shadow-sm border border-gray-200 p-4 sm:p-6 md:p-8">
            <div class="prose max-w-none">
                {{ content }}
            </div>
        </div>
    </div>

    <!-- CTA Section -->
    <div class="mt-8 sm:mt-12 bg-gradient-to-r from-blue-50 to-purple-50 rounded-xl sm:rounded-2xl p-4 sm:p-6 md:p-8 text-center">
        <h2 class="text-xl sm:text-2xl font-bold text-gray-900 mb-3 sm:mb-4">Ready to Start Learning?</h2>
        <p class="text-sm sm:text-base text-gray-600 mb-4 sm:mb-6">Join thousands of learners using Lumorik AI to achieve their goals.</p>
        <div class="flex flex-col sm:flex-row gap-3 sm:gap-4 justify-center">
            <a href="https://ai.tutor.lumorik.com" class="px-4 sm:px-6 py-2.5 sm:py-3 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-lg hover:shadow-lg transition font-medium text-sm sm:text-base">
                Start Your Journey
            </a>
            <a href="{{ '/' | relative_url }}" class="px-4 sm:px-6 py-2.5 sm:py-3 bg-white text-gray-700 rounded-lg border border-gray-300 hover:border-gray-400 transition font-medium text-sm sm:text-base">
                Browse More Plans
            </a>
        </div>
    </div>
</article>

<!-- Knowledge Graph Visualization Script -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('knowledge-graph-canvas');
    const ctx = canvas.getContext('2d');
    
    // High DPI support
    const dpr = window.devicePixelRatio || 1;
    
    // Set actual canvas size
    function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Parse study plan data
    const listView = document.getElementById('list-view');
    const proseDiv = listView.querySelector('.prose') || listView;
    const studyPlanData = parseStudyPlan(proseDiv.innerHTML);
    
    // Color schemes for different module categories
    const colorSchemes = {
        fundamentals: { bg: '#3b82f6', border: '#2563eb', text: '#ffffff' }, // Blue
        architecture: { bg: '#8b5cf6', border: '#7c3aed', text: '#ffffff' }, // Purple
        operations: { bg: '#ec4899', border: '#db2777', text: '#ffffff' },   // Pink
        networking: { bg: '#06b6d4', border: '#0891b2', text: '#ffffff' },   // Cyan
        storage: { bg: '#f59e0b', border: '#d97706', text: '#ffffff' },      // Amber
        security: { bg: '#ef4444', border: '#dc2626', text: '#ffffff' },     // Red
        monitoring: { bg: '#10b981', border: '#059669', text: '#ffffff' },   // Emerald
        advanced: { bg: '#6366f1', border: '#4f46e5', text: '#ffffff' }      // Indigo
    };
    
    const moduleColors = [
        colorSchemes.fundamentals,
        colorSchemes.architecture,
        colorSchemes.operations,
        colorSchemes.networking,
        colorSchemes.storage,
        colorSchemes.security,
        colorSchemes.monitoring,
        colorSchemes.advanced
    ];
    
    // Layout configuration
    let boxes = [];
    let connections = [];
    let hoveredBox = null;
    let camera = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    
    function parseStudyPlan(html) {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        const planData = {
            title: "{{ page.title }}",
            modules: []
        };
        
        let currentModule = null;
        let moduleIndex = 0;
        
        // Find all elements and parse
        const allElements = doc.body.querySelectorAll('*');
        
        allElements.forEach(elem => {
            if (elem.tagName === 'H3' && elem.textContent.includes('Module')) {
                moduleIndex++;
                currentModule = {
                    name: elem.textContent.replace(/Module \d+: /, ''),
                    index: moduleIndex,
                    subtopics: [],
                    description: ''
                };
                planData.modules.push(currentModule);
            } else if (elem.tagName === 'P' && currentModule && !currentModule.subtopics.length && elem.textContent.trim()) {
                currentModule.description = elem.textContent.substring(0, 100) + '...';
            } else if (elem.tagName === 'UL' && currentModule) {
                const items = elem.querySelectorAll('li');
                items.forEach((item, idx) => {
                    if (idx < 5) { // Limit to 5 subtopics for space
                        const link = item.querySelector('a');
                        currentModule.subtopics.push({
                            name: link ? link.textContent.replace(' üìñ', '') : item.textContent,
                            hasTextbook: link !== null
                        });
                    }
                });
            }
        });
        
        return planData;
    }
    
    function createLayout(data) {
        boxes = [];
        connections = [];
        
        const canvasWidth = canvas.width / dpr;
        const canvasHeight = canvas.height / dpr;
        
        // Calculate layout based on number of modules
        const moduleCount = data.modules.length;
        
        // Center title box
        const titleBox = {
            id: 'title',
            text: data.title,
            x: canvasWidth / 2 - 200,
            y: 30,
            width: 400,
            height: 60,
            color: { bg: '#10b981', border: '#059669', text: '#ffffff' },
            type: 'title',
            fontSize: 18,
            fontWeight: 'bold'
        };
        boxes.push(titleBox);
        
        // Layout modules in a grid pattern with more spacing for surrounding subtopics
        let layoutConfig;
        if (moduleCount <= 4) {
            // 2x2 grid
            layoutConfig = { cols: 2, rows: 2 };
        } else if (moduleCount <= 6) {
            // 3x2 grid
            layoutConfig = { cols: 3, rows: 2 };
        } else {
            // 4x2 grid for 7-8 modules
            layoutConfig = { cols: 4, rows: 2 };
        }
        
        const moduleWidth = 160;
        const moduleHeight = 45;
        const spacing = 250; // More space between modules for subtopics
        const startX = (canvasWidth - (layoutConfig.cols * moduleWidth + (layoutConfig.cols - 1) * spacing)) / 2;
        const startY = 150;
        
        data.modules.forEach((module, idx) => {
            const col = idx % layoutConfig.cols;
            const row = Math.floor(idx / layoutConfig.cols);
            const x = startX + col * spacing;
            const y = startY + row * spacing;
            
            // Module container box
            const moduleBox = {
                id: `module-${idx}`,
                text: module.name,
                x: x,
                y: y,
                width: moduleWidth,
                height: 50,
                color: moduleColors[idx % moduleColors.length],
                type: 'module',
                fontSize: 13,
                fontWeight: 'bold',
                module: module
            };
            boxes.push(moduleBox);
            
            // Connect to title
            connections.push({
                from: titleBox,
                to: moduleBox,
                style: 'solid'
            });
            
            // Add subtopic boxes AROUND the module (like satellites)
            const subtopicWidth = 140;
            const subtopicHeight = 28;
            const radius = 100; // Distance from module center
            
            module.subtopics.forEach((subtopic, subIdx) => {
                // Calculate angle for each subtopic around the module
                const angleStep = (Math.PI * 2) / Math.max(module.subtopics.length, 4);
                const angle = angleStep * subIdx - Math.PI / 2; // Start from top
                
                // Position subtopic around the module
                const subtopicX = x + moduleWidth/2 + Math.cos(angle) * radius - subtopicWidth/2;
                const subtopicY = y + moduleHeight/2 + Math.sin(angle) * radius - subtopicHeight/2;
                
                const subtopicBox = {
                    id: `subtopic-${idx}-${subIdx}`,
                    text: subtopic.name.length > 20 ? subtopic.name.substring(0, 20) + '...' : subtopic.name,
                    x: subtopicX,
                    y: subtopicY,
                    width: subtopicWidth,
                    height: subtopicHeight,
                    color: subtopic.hasTextbook 
                        ? { bg: '#f97316', border: '#ea580c', text: '#ffffff' }
                        : { bg: '#4b5563', border: '#374151', text: '#ffffff' },
                    type: 'subtopic',
                    fontSize: 10,
                    fontWeight: 'normal',
                    hasTextbook: subtopic.hasTextbook,
                    parentModule: moduleBox
                };
                boxes.push(subtopicBox);
                
                // Connect to module with dashed line
                connections.push({
                    from: moduleBox,
                    to: subtopicBox,
                    style: 'dashed'
                });
            });
            
            // Connect adjacent modules in sequence
            if (idx > 0) {
                const prevModule = boxes.find(b => b.id === `module-${idx-1}`);
                connections.push({
                    from: prevModule,
                    to: moduleBox,
                    style: 'arrow',
                    color: '#6b7280'
                });
            }
        });
    }
    
    function drawBox(box) {
        // Draw shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(box.x + 2, box.y + 2, box.width, box.height);
        
        // Draw box background
        ctx.fillStyle = box.color.bg;
        ctx.fillRect(box.x, box.y, box.width, box.height);
        
        // Draw border
        ctx.strokeStyle = box.color.border;
        ctx.lineWidth = box === hoveredBox ? 3 : 2;
        ctx.strokeRect(box.x, box.y, box.width, box.height);
        
        // Draw text
        ctx.fillStyle = box.color.text;
        ctx.font = `${box.fontWeight} ${box.fontSize}px system-ui, -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Draw text (handle multiline for long text)
        const maxWidth = box.width - 10;
        const words = box.text.split(' ');
        let line = '';
        let lines = [];
        
        words.forEach(word => {
            const testLine = line + (line ? ' ' : '') + word;
            const metrics = ctx.measureText(testLine);
            if (metrics.width > maxWidth && line) {
                lines.push(line);
                line = word;
            } else {
                line = testLine;
            }
        });
        if (line) lines.push(line);
        
        const lineHeight = box.fontSize + 4;
        const startY = box.y + box.height / 2 - (lines.length - 1) * lineHeight / 2;
        lines.forEach((text, idx) => {
            ctx.fillText(text, box.x + box.width / 2, startY + idx * lineHeight);
        });
        
        // Add textbook icon if applicable
        if (box.hasTextbook) {
            ctx.fillText('üìñ', box.x + box.width - 15, box.y + 15);
        }
    }
    
    function drawConnection(conn) {
        const fromCenter = {
            x: conn.from.x + conn.from.width / 2,
            y: conn.from.y + conn.from.height / 2
        };
        const toCenter = {
            x: conn.to.x + conn.to.width / 2,
            y: conn.to.y + conn.to.height / 2
        };
        
        ctx.strokeStyle = conn.color || '#6b7280';
        ctx.lineWidth = conn.style === 'arrow' ? 2 : 1;
        ctx.globalAlpha = conn.style === 'dashed' ? 0.5 : 0.8;
        
        if (conn.style === 'dashed') {
            ctx.setLineDash([4, 4]);
        } else {
            ctx.setLineDash([]);
        }
        
        ctx.beginPath();
        
        if (conn.from.type === 'title' && conn.to.type === 'module') {
            // Title to module: draw from bottom of title to top of module
            const fromPoint = { x: fromCenter.x, y: conn.from.y + conn.from.height };
            const toPoint = { x: toCenter.x, y: conn.to.y };
            
            // Curved path
            const controlY = fromPoint.y + (toPoint.y - fromPoint.y) * 0.5;
            ctx.moveTo(fromPoint.x, fromPoint.y);
            ctx.quadraticCurveTo(fromPoint.x, controlY, toPoint.x, toPoint.y);
            
        } else if (conn.from.type === 'module' && conn.to.type === 'subtopic') {
            // Module to subtopic: straight line from edge to edge
            const dx = toCenter.x - fromCenter.x;
            const dy = toCenter.y - fromCenter.y;
            const angle = Math.atan2(dy, dx);
            
            // Calculate edge points
            const fromPoint = {
                x: fromCenter.x + Math.cos(angle) * (conn.from.width / 2),
                y: fromCenter.y + Math.sin(angle) * (conn.from.height / 2)
            };
            const toPoint = {
                x: toCenter.x - Math.cos(angle) * (conn.to.width / 2),
                y: toCenter.y - Math.sin(angle) * (conn.to.height / 2)
            };
            
            ctx.moveTo(fromPoint.x, fromPoint.y);
            ctx.lineTo(toPoint.x, toPoint.y);
            
        } else if (conn.style === 'arrow') {
            // Module to module connections: route around to avoid crossing
            const fromPoint = { x: conn.from.x + conn.from.width, y: fromCenter.y };
            const toPoint = { x: conn.to.x, y: toCenter.y };
            
            // Check if modules are on same row
            const sameRow = Math.abs(fromCenter.y - toCenter.y) < 50;
            
            if (sameRow) {
                // Direct horizontal connection
                ctx.moveTo(fromPoint.x, fromPoint.y);
                ctx.lineTo(toPoint.x, toPoint.y);
                
                // Draw arrow
                const arrowLength = 8;
                ctx.moveTo(toPoint.x, toPoint.y);
                ctx.lineTo(toPoint.x - arrowLength, toPoint.y - arrowLength/2);
                ctx.moveTo(toPoint.x, toPoint.y);
                ctx.lineTo(toPoint.x - arrowLength, toPoint.y + arrowLength/2);
            } else {
                // Route down and across for modules on different rows
                const midX = fromPoint.x + 30;
                const bendY = fromCenter.y + (toCenter.y > fromCenter.y ? 60 : -60);
                
                ctx.moveTo(fromPoint.x, fromPoint.y);
                ctx.lineTo(midX, fromPoint.y);
                ctx.lineTo(midX, bendY);
                ctx.lineTo(toPoint.x - 30, bendY);
                ctx.lineTo(toPoint.x - 30, toPoint.y);
                ctx.lineTo(toPoint.x, toPoint.y);
                
                // Draw arrow
                const arrowLength = 8;
                ctx.moveTo(toPoint.x, toPoint.y);
                ctx.lineTo(toPoint.x - arrowLength, toPoint.y - arrowLength/2);
                ctx.moveTo(toPoint.x, toPoint.y);
                ctx.lineTo(toPoint.x - arrowLength, toPoint.y + arrowLength/2);
            }
        } else {
            // Default straight line
            ctx.moveTo(fromCenter.x, fromCenter.y);
            ctx.lineTo(toCenter.x, toCenter.y);
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
    }
    
    function draw() {
        // Clear canvas
        ctx.fillStyle = '#111827';
        ctx.fillRect(0, 0, canvas.width / dpr, canvas.height / dpr);
        
        ctx.save();
        ctx.translate(camera.x, camera.y);
        
        // Draw connections first
        connections.forEach(conn => drawConnection(conn));
        
        // Draw boxes on top
        boxes.forEach(box => drawBox(box));
        
        ctx.restore();
    }
    
    // Mouse interactions
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        dragStart.x = e.offsetX - camera.x;
        dragStart.y = e.offsetY - camera.y;
        canvas.style.cursor = 'grabbing';
    });
    
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left - camera.x;
        const y = e.clientY - rect.top - camera.y;
        
        if (isDragging) {
            camera.x = e.offsetX - dragStart.x;
            camera.y = e.offsetY - dragStart.y;
            draw();
        } else {
            // Check hover
            const prevHovered = hoveredBox;
            hoveredBox = null;
            
            boxes.forEach(box => {
                if (x >= box.x && x <= box.x + box.width &&
                    y >= box.y && y <= box.y + box.height) {
                    hoveredBox = box;
                    canvas.style.cursor = 'pointer';
                }
            });
            
            if (!hoveredBox) {
                canvas.style.cursor = 'grab';
            }
            
            if (prevHovered !== hoveredBox) {
                draw();
            }
        }
    });
    
    canvas.addEventListener('mouseup', () => {
        isDragging = false;
        canvas.style.cursor = 'grab';
    });
    
    // View toggles
    document.getElementById('view-knowledge').addEventListener('click', () => {
        document.getElementById('knowledge-graph-view').classList.remove('hidden');
        document.getElementById('list-view').classList.add('hidden');
        document.getElementById('view-knowledge').classList.add('bg-white/20');
        document.getElementById('view-knowledge').classList.remove('bg-white/10');
        document.getElementById('view-list').classList.add('bg-white/10');
        document.getElementById('view-list').classList.remove('bg-white/20');
        resizeCanvas();
        draw();
    });
    
    document.getElementById('view-list').addEventListener('click', () => {
        document.getElementById('list-view').classList.remove('hidden');
        document.getElementById('knowledge-graph-view').classList.add('hidden');
        document.getElementById('view-list').classList.add('bg-white/20');
        document.getElementById('view-list').classList.remove('bg-white/10');
        document.getElementById('view-knowledge').classList.add('bg-white/10');
        document.getElementById('view-knowledge').classList.remove('bg-white/20');
    });
    
    // Initialize
    createLayout(studyPlanData);
    draw();
});
</script>

<style>
#knowledge-graph-canvas {
    cursor: grab;
    image-rendering: crisp-edges;
}

#knowledge-graph-canvas:active {
    cursor: grabbing;
}
</style>